[{
    "title": "数独（使用C++)",
    "date": "June 28, 2020",
    "description": "回溯法还是深度优先搜寻？其实我也不知道",
    "body": "ㅤㅤㅤ\n数独C++想法 有一天我去看了上清大资工同学的备审\n奖项跟参赛记录多到哭出来啊，是完全无法触及的级别\n但是他有提到他有用Excel写一个2*2的数独\n刚好我最近在读关于dfs的东西，想说不然来玩玩看\n逻辑应该差不多，就是比较不那麽暴力的穷举\n正式开始 先建立一个全域的int阵列当做map\nint map[9][9]\n然后建立一个用来检测输入的数字是否符合条件的函数\n条件如下:\n   范围 条件A 条件B     x相同的9个格子 格子内的数字互不相等 数字为1~9   y相同的9个格子 格子内的数字互不相等 数字为1~9   划分在同一个小格子的9个格子 格子内的数字互不相等 数字为1~9    这边的count是跑到第count格的意思\n从第1格开始跑，到第(9*9)格结束\n先计算当前count值下的坐标\nint y = count / 9; int x = count % 9; 检查y相同的状况，\nfor (int i = 0; i \u0026lt; 9; ++i) //当發现y相同时有点的值和代入的值相同时就return false  if (map[y][i] == map[y][x] \u0026amp;\u0026amp; i != x) return false; 检查x相同的状况\nfor (int i = 0; i \u0026lt; 9; ++i) //当發现x相同时有点的值和代入的值相同时就return false \tif (map[i][x] == map[y][x] \u0026amp;\u0026amp; i != y) return false; 检查同一小格的状况\n//sx,sy指小格子的坐标 //x,y的范围是0~8,至于公式可以自己拿纸笔推推看 int sy = y / 3 * 3; int sx = x / 3 * 3; for (int i = sy; i \u0026lt; sy + 3; ++i) for (int k = sx; k \u0026lt; sx + 3; ++k) if (map[i][k] == map[y][x] \u0026amp;\u0026amp; i != y \u0026amp;\u0026amp; k != x) return false; 当到了这边就代表前面都没有return也就是这个值是没问题的\n这时候就return true;\n 完整的Test函数长这样\nbool Test(int count) { int y = count / 9; int x = count % 9; //y相同 \tfor (int i = 0; i \u0026lt; 9; ++i) if (map[y][i] == map[y][x] \u0026amp;\u0026amp; i != x) return false; //x相同 \tfor (int i = 0; i \u0026lt; 9; ++i) if (map[i][x] == map[y][x] \u0026amp;\u0026amp; i != y) return false; //同一小格 \tint sy = y / 3 * 3; int sx = x / 3 * 3; for (int i = sy; i \u0026lt; sy + 3; ++i) for (int k = sx; k \u0026lt; sx + 3; ++k) if (map[i][k] == map[y][x] \u0026amp;\u0026amp; i != y \u0026amp;\u0026amp; k != x) return false; return true; } 然后是BackTracking的部分了(我这样玩好像有dfs的味道，但我不确定是不是dfs)\n我把这个函数取名叫guess\n第一步先判断是不是走到终点了\n也就是count的值是否为81\nif (count == 81) //如果是81就把map整个印出来再return  { for (int i = 0; i \u0026lt; 9; ++i) { for (int j = 0; j \u0026lt; 9; ++j) cout \u0026lt;\u0026lt; map[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } return; } 确定了现在走的点不是最后一个点之后\n这裡一样要计算count当下x,y的值\nint y = count / 9; int x = count % 9; 这时候分成两种情况\n   情况 动作     当前位置没有数字(map[y][x]==0) 开始在这一格做尝试   当前位置已有数字(map[y][x]!=0) 直接呼叫下一层    这边好像就比较有dfs的味道了\n一个值试过之后当前格再重置为0继续试下一个值\n当前位置没有数字时:\nif (map[y][x] == 0) { for (int i = 1; i \u0026lt;= 9; ++i) { //给值标记已经使用过 \tmap[y][x] = i; //当检测合格的时候就再进到下一层  if (Test(count)) guess(count + 1); } //重置该点数值 \tmap[y][x] = 0; } 当前位置有数字时：\nelse //直接进入下一层  guess(count + 1); 整个guess函数长这样：\nvoid guess(int count) { if (count == 81) { for (int i = 0; i \u0026lt; 9; ++i) { for (int j = 0; j \u0026lt; 9; ++j) cout \u0026lt;\u0026lt; map[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } return; } int y = count / 9; int x = count % 9; if (map[y][x] == 0) { for (int i = 1; i \u0026lt;= 9; ++i) { //给值标记已经使用过 \tmap[y][x] = i; if (Test(count)) guess(count + 1); } //重置该点数值 \tmap[y][x] = 0; } else guess(count + 1); } 最后一步就是main函数啦~\n就只有输入map的值然后guess(0)\n注意这边输入格式空格以0代替 int main() { for (int i = 0; i \u0026lt; 9; ++i) for (int j = 0; j \u0026lt; 9; ++j) cin \u0026gt;\u0026gt; map[i][j]; cout \u0026lt;\u0026lt; endl; guess(0); return 0; } 我是在图书馆把这一串给写完的\n写完之后我就坐在那边开外挂完了半小时数独(刚好IG广告就是数独我吓到)\n完整的程式码：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int map[9][9]; bool Test(int count) { int y = count / 9; int x = count % 9; //同一行 \tfor (int i = 0; i \u0026lt; 9; ++i) if (map[y][i] == map[y][x] \u0026amp;\u0026amp; i != x) return false; //同一列 \tfor (int i = 0; i \u0026lt; 9; ++i) if (map[i][x] == map[y][x] \u0026amp;\u0026amp; i != y) return false; //同一小格 \tint sy = y / 3 * 3; int sx = x / 3 * 3; for (int i = sy; i \u0026lt; sy + 3; ++i) for (int k = sx; k \u0026lt; sx + 3; ++k) if (map[i][k] == map[y][x] \u0026amp;\u0026amp; i != y \u0026amp;\u0026amp; k != x) return false; return true; } void guess(int count) { if (count == 81) { for (int i = 0; i \u0026lt; 9; ++i) { for (int j = 0; j \u0026lt; 9; ++j) cout \u0026lt;\u0026lt; map[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } return; } int y = count / 9; int x = count % 9; if (map[y][x] == 0) { for (int i = 1; i \u0026lt;= 9; ++i) { //给值标记已经使用过 \tmap[y][x] = i; if (Test(count)) guess(count + 1); } //重置该点数值 \tmap[y][x] = 0; } else guess(count + 1); } int main() { for (int i = 0; i \u0026lt; 9; ++i) for (int j = 0; j \u0026lt; 9; ++j) cin \u0026gt;\u0026gt; map[i][j]; cout \u0026lt;\u0026lt; endl; guess(0); return 0; } ",
    "ref": "/cn/blog/sudoku/"
  },{
    "title": "关于APCS的抱怨",
    "date": "June 27, 2020",
    "description": "About The Spaghetti Code",
    "body": "ㅤㅤ\nAPCS(大学程式设计先修检定) 在APCS的观念题中有一种很麻烦的题目是 code tracing\n一开始想说应该还好，毕竟也不是没有看过别人的程式码，应该跟着跑一次就好了\n天真如我\n一时找不到之前绕到头晕掉的题目，随便举一个考古题的例子，还算简单的\n若以F(15)呼叫右侧F()函式，总共会印出几行数字？\nvoid F(int n) { printf(\u0026quot;%d\\n\u0026quot;,n); if(n%2==1)\u0026amp;\u0026amp;(n\u0026gt;1) { return F(5*n+1) } else { if(n%2==0) return F(n/2); } } 解题思路：\n当函式输进一个变数n,此时分为两种状况\n   条件 动作     n为偶数 回传F(n/2)   n不为偶数 回传F(5*n+1)    这时候n的变化如下\n   印出次数 此时的n值     01 15   02 76   03 38   04 19   05 96   06 48   07 24   08 12   09 06   10 03   11 16   12 08   13 04   14 02   15 01    Answer == 15\n全题考到的观念只有\n 条件判断 简单的运算 函数  明明只是考三个很简单的观念却硬要强行绕15次再问考生绕了几次\n让人不禁怀疑到底出这样的题目对于程式能力的检定是否真的有帮助?\n我记得我在APCS的社团有看过别人说：想要程式写得好，请认真看APCS观念题并引以为戒\n也有人说 APCS = A lot of Problems Caused by Spaghetti code\n至少在我少少的解题经验中完全没有用过这麽没有逻辑的东西\n或者是这题\nint g1 = 30; int g2 = 20; int f1(int v) { int g1 = 10; return g1 + v; } int f2(int v) { int c = g2; v = v + c + g1; g1 = 10; c = 40; return v; } int main() { g2 = 0; g2 = f1(g2); printf(\u0026quot;%d\u0026quot;, f2(f2(g2))); } 很明显这题考观念有：\n 函数 变数形态(全域以及区域变数)  除了打算折磨考生的出题者，基本上没有人写程式会故意让全域变数跟区域变数同名\n然后今年7月的APCS名额变少，报名的人好像有变多\n记错日期的我只能放逐离岛了QAQ OAO報不到本島啦 pic.twitter.com/t8toz2B8tR\n\u0026mdash; 肝臟爆破藝術家 (@CalvinWan0101) June 27, 2020  希望今年的观念题可以顺顺利利的PASS :D\n",
    "ref": "/cn/blog/apcs/"
  },{
    "title": "Blog 的起源",
    "date": "June 26, 2020",
    "description": "来自猫猫大神的超优质提案",
    "body": "ㅤㅤ\nCalvin Blog 的起源 前几天不知道GitHub如果作为个人申请备审资料应该怎麽分类的我游走在ptt的SeniorHigh版中\n无意中看到一个清大资工备取的备审 点这里\n晚上拿去就和猫猫大神分享了\n她觉得做得不够好但是她有提说如果那个人如果把他备审的东西建一个blog丢进去应该会很厉害\n一瞬间觉得天啊猫猫大神是天才吧，平常看起来什麽都不会的她竟然有办法提出这麽U质的点子\n于是抱持着 做备审的心态 开始了我的Blog建置\n但是猫猫大神觉得只是为了给教授看而经营blog很废，我也这样觉得\n刚好我是个小剧场很多的人，然后7月考完APCS我就要去重考班待着了\n可能可以写一些在重考班的所见所闻啊或是读书心得之类的\nGitHub 可能拿来放一些比较正式的东西\nBlog 就拿来分享生活，记录一些有趣的事或是心得分享\n总之这就是Calvin Blog 的起源了\n",
    "ref": "/cn/blog/orgin/"
  },{
    "title": "关于",
    "date": "June 26, 2020",
    "description": "协同中学高四学生",
    "body": "父亲毕业于国防理工学院，现在是一名工程师，从小在父亲的影响下耳濡目染，对于资讯硬体有了最初的启蒙。国中时因为敬仰父亲的成就，便暗自下定决心要踏上理工的路。父亲总是要求我多问多思考，对于一个现象的产生会是什麽原因造成的，假设出不同的可能原因再逐一证明。就像程式出bug，原因可能出在文法，逻辑错误，或是单纯编译器出故障，订出有可能的选项再一一检查验证。父亲培养我我解决问题的能力，在问题中找到自己观念的缺失，逻辑的错误，再针对不足的地方加强，我从问题中学习也从问题中成长。\n高中时凭藉着对于数学以及物理的喜好毅然决然的选择了二类。面对複杂的物理观念，比起背题目或是公式，我更倾向于透过自我思考将结论一步步推导出来，不仅能避免填鸭式教育带来的后遗症也能训练我逻辑思考的能力。数学和写程式的逻辑我认为大同小异，统整自己所有的方法，针对问题建立出一套流程，再运用已知的方法慢慢填充。通往答案的路不止一条，只不过是快慢的差异。透过不断地思考不断地练习，随着经验的累积，最终总能找到更快更有效率的方法。思考直到求得解答的过程不断地刺激我对于数学的热忱，我想要这份热忱运用在我未来的专业之中，这也是我选择资工系很重要的原因。\n在初二选择社团时加入了电脑社，对于电脑的硬体以及软体设计有了初步的了解。后来有一段时间沉迷于电动，但碍于硬体资源差往往无法得到良好的游戏体验，所以我开始自学电脑硬体的相关知识。从CPU的型号，显卡的尾数，散热问题，供电问题，甚至到RAM DDR3与DDR4的差别都有去做相关的探究。 国中因为使用习惯不良，被强行安装许多附带软体导致电脑常常记忆体满载或是中毒，因为花钱重灌的次数实在太多，后来自己便学会了重灌及切割硬碟。\n高中时选修了程式语言C++，此举实属打开了我新世界的大门。一行行程式码背后是缜密的思考以及谨慎的逻辑推演。第一次感受到不是电脑在控制我，而是我在控制电脑。让我印象深刻的便是Debug，其过程繁琐而複杂，往往要消耗掉的时间比起真正写程式的时间还久，但每次的debug都是对自己思路的二次审核，由每个错误發现自己逻辑上的疏失，从中学习并修正自己的思维并在下次写程式时注意不要犯相同的错误。看到自己写的程式成功的跑完了，Debug时的劳累早已烟消云散，脑海中留下的只有满满的成就感。\n",
    "ref": "/cn/about/"
  },{
    "title": "如果有什么问题欢迎联系我",
    "date": "January 1, 0001",
    "description": "",
    "body": "",
    "ref": "/cn/contact/"
  }]
