[{
    "title": "SUDOKU WITH C++",
    "date": "June 28, 2020",
    "description": "使用 C++ 解決數獨問題",
    "body": "ㅤㅤ\n前情提要 有一天我去看了上清大資工同學的備審\n獎項跟參賽記錄多到哭出來啊，是完全無法觸及的級別\n但是他有提到他有用Excel寫一個2*2的數獨\n剛好我最近在讀關於dfs的東西，想說不然來玩玩看\n邏輯應該差不多，就是比較不那麼暴力的窮舉\n正式開始 先建立一個全域的int陣列當做map\nint map[9][9]\n然後建立一個用來檢測輸入的數字是否符合條件的函數\n條件如下:\n   範圍 條件A 條件B     x相同的9個格子 格子內的數字互不相等 數字為1~9   y相同的9個格子 格子內的數字互不相等 數字為1~9   劃分在同一個小格子的9個格子 格子內的數字互不相等 數字為1~9    這邊的count是跑到第count格的意思\n從第1格開始跑，到第(9*9)格結束\n先計算當前count值下的坐標\nint y = count / 9; int x = count % 9; 檢查y相同的狀況，\nfor (int i = 0; i \u0026lt; 9; ++i) //當發現y相同時有點的值和代入的值相同時就return false  if (map[y][i] == map[y][x] \u0026amp;\u0026amp; i != x) return false; 檢查x相同的狀況\nfor (int i = 0; i \u0026lt; 9; ++i) //當發現x相同時有點的值和代入的值相同時就return false \tif (map[i][x] == map[y][x] \u0026amp;\u0026amp; i != y) return false; 檢查同一小格的狀況\n//sx,sy指小格子的坐標 //x,y的範圍是0~8,至於公式可以自己拿紙筆推推看 int sy = y / 3 * 3; int sx = x / 3 * 3; for (int i = sy; i \u0026lt; sy + 3; ++i) for (int k = sx; k \u0026lt; sx + 3; ++k) if (map[i][k] == map[y][x] \u0026amp;\u0026amp; i != y \u0026amp;\u0026amp; k != x) return false; 當到了這邊就代表前面都沒有return也就是這個值是沒問題的\n這時候就return true;\n 完整的Test函數長這樣\nbool Test(int count) { int y = count / 9; int x = count % 9; //y相同 \tfor (int i = 0; i \u0026lt; 9; ++i) if (map[y][i] == map[y][x] \u0026amp;\u0026amp; i != x) return false; //x相同 \tfor (int i = 0; i \u0026lt; 9; ++i) if (map[i][x] == map[y][x] \u0026amp;\u0026amp; i != y) return false; //同一小格 \tint sy = y / 3 * 3; int sx = x / 3 * 3; for (int i = sy; i \u0026lt; sy + 3; ++i) for (int k = sx; k \u0026lt; sx + 3; ++k) if (map[i][k] == map[y][x] \u0026amp;\u0026amp; i != y \u0026amp;\u0026amp; k != x) return false; return true; } 然後是BackTracking的部分了(我這樣玩好像有dfs的味道，但我不確定是不是dfs)\n我把這個函數取名叫guess\n第一步先判斷是不是走到終點了\n也就是count的值是否為81\nif (count == 81) //如果是81就把map整個印出來再return  { for (int i = 0; i \u0026lt; 9; ++i) { for (int j = 0; j \u0026lt; 9; ++j) cout \u0026lt;\u0026lt; map[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } return; } 確定了現在走的點不是最後一個點之後\n這裡一樣要計算count當下x,y的值\nint y = count / 9; int x = count % 9; 這時候分成兩種情況\n   情況 動作     當前位置沒有數字(map[y][x]==0) 開始在這一格做嘗試   當前位置已有數字(map[y][x]!=0) 直接呼叫下一層    這邊好像就比較有dfs的味道了\n一個值試過之後當前格再重置為0繼續試下一個值\n當前位置沒有數字時:\nif (map[y][x] == 0) { for (int i = 1; i \u0026lt;= 9; ++i) { //給值標記已經使用過 \tmap[y][x] = i; //當檢測合格的時候就再進到下一層  if (Test(count)) guess(count + 1); } //重置該點數值 \tmap[y][x] = 0; } 當前位置有數字時：\nelse //直接進入下一層  guess(count + 1); 整個guess函數長這樣：\nvoid guess(int count) { if (count == 81) { for (int i = 0; i \u0026lt; 9; ++i) { for (int j = 0; j \u0026lt; 9; ++j) cout \u0026lt;\u0026lt; map[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } return; } int y = count / 9; int x = count % 9; if (map[y][x] == 0) { for (int i = 1; i \u0026lt;= 9; ++i) { //給值標記已經使用過 \tmap[y][x] = i; if (Test(count)) guess(count + 1); } //重置該點數值 \tmap[y][x] = 0; } else guess(count + 1); } 最後一步就是main函數啦~\n就只有輸入map的值然後guess(0)\n注意這邊輸入格式空格以0代替 int main() { for (int i = 0; i \u0026lt; 9; ++i) for (int j = 0; j \u0026lt; 9; ++j) cin \u0026gt;\u0026gt; map[i][j]; cout \u0026lt;\u0026lt; endl; guess(0); return 0; } 我是在圖書館把這一串給寫完的\n寫完之後我就坐在那邊開外掛完了半小時數獨(剛好IG廣告就是數獨我嚇到)\n完整的程式碼：\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int map[9][9]; bool Test(int count) { int y = count / 9; int x = count % 9; //同一行 \tfor (int i = 0; i \u0026lt; 9; ++i) if (map[y][i] == map[y][x] \u0026amp;\u0026amp; i != x) return false; //同一列 \tfor (int i = 0; i \u0026lt; 9; ++i) if (map[i][x] == map[y][x] \u0026amp;\u0026amp; i != y) return false; //同一小格 \tint sy = y / 3 * 3; int sx = x / 3 * 3; for (int i = sy; i \u0026lt; sy + 3; ++i) for (int k = sx; k \u0026lt; sx + 3; ++k) if (map[i][k] == map[y][x] \u0026amp;\u0026amp; i != y \u0026amp;\u0026amp; k != x) return false; return true; } void guess(int count) { if (count == 81) { for (int i = 0; i \u0026lt; 9; ++i) { for (int j = 0; j \u0026lt; 9; ++j) cout \u0026lt;\u0026lt; map[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } return; } int y = count / 9; int x = count % 9; if (map[y][x] == 0) { for (int i = 1; i \u0026lt;= 9; ++i) { //給值標記已經使用過 \tmap[y][x] = i; if (Test(count)) guess(count + 1); } //重置該點數值 \tmap[y][x] = 0; } else guess(count + 1); } int main() { for (int i = 0; i \u0026lt; 9; ++i) for (int j = 0; j \u0026lt; 9; ++j) cin \u0026gt;\u0026gt; map[i][j]; cout \u0026lt;\u0026lt; endl; guess(0); return 0; } ",
    "ref": "/blog/sudoku/"
  },{
    "title": "complain about APCS",
    "date": "June 27, 2020",
    "description": "About The Spaghetti Code",
    "body": "ㅤㅤ\nAPCS(大學程式設計先修檢定) 在APCS的觀念題中有一種很麻煩的題目是 code tracing\n一開始想說應該還好，畢竟也不是沒有看過別人的程式碼，應該跟著跑一次就好了\n天真如我\n一時找不到之前繞到頭暈掉的題目，隨便舉一個考古題的例子，還算簡單的\n若以F(15)呼叫右側F()函式，總共會印出幾行數字？\nvoid F(int n) { printf(\u0026#34;%d\\n\u0026#34;,n); if(n%2==1)\u0026amp;\u0026amp;(n\u0026gt;1) { return F(5*n+1) } else { if(n%2==0) return F(n/2); } } 解題思路：\n當函式輸進一個變數n,此時分為兩種狀況\n   條件 動作     n為偶數 回傳F(n/2)   n不為偶數 回傳F(5*n+1)    這時候n的變化如下\n   印出次數 此時的n值     01 15   02 76   03 38   04 19   05 96   06 48   07 24   08 12   09 06   10 03   11 16   12 08   13 04   14 02   15 01    Answer == 15\n全題考到的觀念只有\n 條件判斷 簡單的運算 函數  明明只是考三個很簡單的觀念卻硬要強行繞15次再問考生繞了幾次\n讓人不禁懷疑到底出這樣的題目對於程式能力的檢定是否真的有幫助?\n我記得我在APCS的社團有看過別人說：想要程式寫得好，請認真看APCS觀念題並引以為戒\n也有人說 APCS = A lot of Problems Caused by Spaghetti code\n至少在我少少的解題經驗中完全沒有用過這麼沒有邏輯的東西\n或者是這題\nint g1 = 30; int g2 = 20; int f1(int v) { int g1 = 10; return g1 + v; } int f2(int v) { int c = g2; v = v + c + g1; g1 = 10; c = 40; return v; } int main() { g2 = 0; g2 = f1(g2); printf(\u0026#34;%d\u0026#34;, f2(f2(g2))); } 很明顯這題考觀念有：\n 函數 變數形態(全域以及區域變數)  除了打算折磨考生的出題者，基本上沒有人寫程式會故意讓全域變數跟區域變數同名\n然後今年7月的APCS名額變少，報名的人好像有變多\n記錯日期的我只能放逐離島了QAQ OAO報不到本島啦 pic.twitter.com/t8toz2B8tR\n\u0026mdash; 肝臟爆破藝術家 (@CalvinWan0101) June 27, 2020  希望今年的觀念題可以順順利利的PASS :D\n",
    "ref": "/blog/apcs/"
  },{
    "title": "About",
    "date": "June 26, 2020",
    "description": "Concordia middle school Senior 4 student",
    "body": "父親畢業于國防理工學院，現在是一名工程師，從小在父親的影響下耳濡目染，對於資訊硬體有了最初的啟蒙。國中時因為敬仰父親的成就，便暗自下定決心要踏上理工的路。父親總是要求我多問多思考，對於一個現象的產生會是什麼原因造成的，假設出不同的可能原因再逐一證明。就像程式出bug，原因可能出在文法，邏輯錯誤，或是單純編譯器出故障，訂出有可能的選項再一一檢查驗證。父親培養我我解決問題的能力，在問題中找到自己觀念的缺失，邏輯的錯誤，再針對不足的地方加強，我從問題中學習也從問題中成長。\n高中時憑藉著對於數學以及物理的喜好毅然決然的選擇了二類。面對複雜的物理觀念，比起背題目或是公式，我更傾向於透過自我思考將結論一步步推導出來，不僅能避免填鴨式教育帶來的後遺症也能訓練我邏輯思考的能力。數學和寫程式的邏輯我認為大同小異，統整自己所有的方法，針對問題建立出一套流程，再運用已知的方法慢慢填充。通往答案的路不止一條，只不過是快慢的差異。透過不斷地思考不斷地練習，隨著經驗的累積，最終總能找到更快更有效率的方法。思考直到求得解答的過程不斷地刺激我對於數學的熱忱，我想要這份熱忱運用在我未來的專業之中，這也是我選擇資工系很重要的原因。\n在國二選擇社團時加入了電腦社，對於電腦的硬體以及軟體設計有了初步的了解。後來有一段時間沉迷於電動，但礙於硬體資源差往往無法得到良好的遊戲體驗，所以我開始自學電腦硬體的相關知識。從CPU的型號，顯卡的尾數，散熱問題，供電問題，甚至到RAM DDR3與DDR4的差別都有去做相關的探究。 國中因為使用習慣不良，被強行安裝許多附帶軟體導致電腦常常記憶體滿載或是中毒，因為花錢重灌的次數實在太多，後來自己便學會了重灌及切割硬碟。\n高中時選修了程式語言C++，此舉實屬打開了我新世界的大門。一行行程式碼背後是縝密的思考以及謹慎的邏輯推演。第一次感受到不是電腦在控制我，而是我在控制電腦。讓我印象深刻的便是Debug，其過程繁瑣而複雜，往往要消耗掉的時間比起真正寫程式的時間還久，但每次的debug都是對自己思路的二次審核，由每個錯誤發現自己邏輯上的疏失，從中學習並修正自己的思維並在下次寫程式時注意不要犯相同的錯誤。看到自己寫的程式成功的跑完了，Debug時的勞累早已煙消雲散，腦海中留下的只有滿滿的成就感。\n",
    "ref": "/about/"
  },{
    "title": "Orgin of the blog",
    "date": "June 26, 2020",
    "description": "ヽ(●´∀`●)ﾉ",
    "body": "ㅤㅤ\nCalvin Blog 的起源 前幾天不知道GitHub如果作為個人申請備審資料應該怎麼分類的我遊走在ptt的SeniorHigh版中\n無意中看到一個清大資工備取的備審 Click Here\n晚上拿去就和貓貓大神分享了\n她覺得做得不夠好但是她有提說如果那個人如果把他備審的東西建一個blog丟進去應該會很厲害\n一瞬間覺得天啊貓貓大神是天才吧，平常看起來什麼都不會的她竟然有辦法提出這麼U質的點子\n於是抱持著 做備審的心態開始了我的Blog建置\n但是貓貓大神覺得只是為了給教授看而經營blog很廢，我也這樣覺得\n剛好我是個小劇場很多的人，然後7月考完APCS我就要去重考班待著了\n可能可以寫一些在重考班的所見所聞啊或是讀書心得之類的\nGitHub 可能拿來放一些比較正式的東西\nBlog 就拿來分享生活，記錄一些有趣的事或是心得分享\n總之這就是Calvin Blog 的起源了\n",
    "ref": "/blog/orgin/"
  },{
    "title": "如果有什么问题欢迎联系我",
    "date": "January 1, 0001",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
